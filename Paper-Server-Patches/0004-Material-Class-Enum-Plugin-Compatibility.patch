From 58fcd65804403b3e2d0763ebdfc38b6ff9a3b299 Mon Sep 17 00:00:00 2001
From: Indhi Rousseau <contact@thekinrar.fr>
Date: Wed, 9 Oct 2019 19:50:39 +0100
Subject: [PATCH] Material Class/Enum Plugin Compatibility


diff --git a/pom.xml b/pom.xml
index 54730360f..227b76bab 100644
--- a/pom.xml
+++ b/pom.xml
@@ -119,6 +119,20 @@
             <version>1.3</version>
             <scope>test</scope>
         </dependency>
+        <!-- Paper - javaagent -->
+        <dependency>
+            <groupId>com.sun</groupId>
+            <artifactId>tools</artifactId>
+            <version>1.8.0</version>
+            <scope>system</scope>
+            <systemPath>${java.home}/../lib/tools.jar</systemPath>
+        </dependency>
+        <dependency>
+            <groupId>org.javassist</groupId>
+            <artifactId>javassist</artifactId>
+            <version>3.25.0-GA</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <repositories>
@@ -179,6 +193,11 @@
                             <Specification-Title>Bukkit</Specification-Title>
                             <Specification-Version>${api.version}</Specification-Version>
                             <Specification-Vendor>Bukkit Team</Specification-Vendor>
+
+                            <!-- Paper - javaagent -->
+                            <Agent-Class>org.bukkit.craftbukkit.compat.CompatJavaAgent</Agent-Class>
+                            <Can-Redefine-Classes>true</Can-Redefine-Classes>
+                            <Can-Retransform-Classes>true</Can-Retransform-Classes>
                         </manifestEntries>
                         <manifestSections>
                             <manifestSection>
@@ -254,6 +273,7 @@
                                     <shadedPattern>org.bukkit.craftbukkit.v${minecraft_version}</shadedPattern>
                                     <excludes>
                                         <exclude>org.bukkit.craftbukkit.Main*</exclude>
+                                        <exclude>org.bukkit.craftbukkit.compat.*</exclude>
                                     </excludes>
                                 </relocation>
                                 <relocation>
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 008fb8444..b60bb2830 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -1,24 +1,60 @@
 package org.bukkit.craftbukkit;
 
+import com.sun.tools.attach.VirtualMachine;
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
+import net.minecraft.server.MinecraftServer;
+import net.minecrell.terminalconsole.TerminalConsoleAppender;
+
 import java.io.File;
 import java.io.IOException;
+import java.lang.management.ManagementFactory;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.List;
-import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-import net.minecraft.server.MinecraftServer;
-import net.minecrell.terminalconsole.TerminalConsoleAppender; // Paper
+import java.lang.reflect.Method;
+import java.net.URL;
+import java.net.URLClassLoader;
 
 public class Main {
     public static boolean useJline = true;
     public static boolean useConsole = true;
 
+    static {
+        try {
+            String javaHome = System.getProperty("java.home");
+            String toolsJarURL = "file:" + javaHome + "/../lib/tools.jar";
+
+            // Make addURL public
+            Method method = URLClassLoader.class.getDeclaredMethod("addURL", URL.class);
+            method.setAccessible(true);
+
+            URLClassLoader sysloader = (URLClassLoader)ClassLoader.getSystemClassLoader();
+            if (sysloader.getResourceAsStream("/com/sun/tools/attach/VirtualMachine.class") == null) {
+                method.invoke(sysloader, (Object) new URL(toolsJarURL));
+                Thread.currentThread().getContextClassLoader().loadClass("com.sun.tools.attach.VirtualMachine");
+                Thread.currentThread().getContextClassLoader().loadClass("com.sun.tools.attach.AttachNotSupportedException");
+            }
+        } catch(Exception e) {
+            e.printStackTrace();
+        }
+
+        String vmName = ManagementFactory.getRuntimeMXBean().getName();
+
+        try {
+            VirtualMachine vm = VirtualMachine.attach(vmName.substring(0, vmName.indexOf('@')));
+            vm.loadAgent(new File(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getAbsolutePath());
+            vm.detach();
+        } catch (Exception e) {
+            e.printStackTrace();
+            Runtime.getRuntime().exit(1);
+        }
+    }
+
     public static void main(String[] args) {
         // Todo: Installation script
         OptionParser parser = new OptionParser() {
@@ -238,7 +274,7 @@ public class Main {
                     System.out.println("Unable to read system info");
                 }
                 // Paper end
-                System.setProperty( "library.jansi.version", "Paper" ); // Paper - set meaningless jansi version to prevent git builds from crashing on Windows
+
                 System.out.println("Loading libraries, please wait...");
                 MinecraftServer.main(options);
             } catch (Throwable t) {
diff --git a/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumMap.java b/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumMap.java
new file mode 100644
index 000000000..fdba94ca3
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumMap.java
@@ -0,0 +1,144 @@
+package org.bukkit.craftbukkit.compat;
+
+import org.bukkit.Material;
+
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumMap<K, V> extends AbstractMap<K, V> implements java.io.Serializable, Cloneable {
+
+    private boolean realEnum;
+    private AbstractMap<Object, V> realMap;
+
+    private HashMap<Material, V> materialMap;
+
+    public CompatEnumMap(Class keyType) {
+        if(keyType.isEnum()) {
+            realEnum = true;
+            realMap = new EnumMap(keyType);
+        } else {
+            materialMap = new HashMap<>(Material.values().length);
+        }
+    }
+
+    private AbstractMap<Object, V> cloneRealMap() {
+        try {
+            return (AbstractMap<Object, V>) realMap.getClass().getMethod("clone").invoke(realMap);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public CompatEnumMap(CompatEnumMap<K, ? extends V> m) {
+        realEnum = m.realEnum;
+
+        if(realEnum)
+            realMap = (AbstractMap<Object, V>) m.cloneRealMap();
+        else
+            materialMap = (HashMap<Material, V>) m.materialMap.clone();
+    }
+
+    public CompatEnumMap(Map<K, ? extends V> m) {
+        if (m instanceof CompatEnumMap) {
+            CompatEnumMap<K, ? extends V> em = (CompatEnumMap<K, ? extends V>) m;
+
+            realEnum = em.realEnum;
+
+            if(realEnum)
+                realMap = (AbstractMap<Object, V>) em.cloneRealMap();
+            else
+                materialMap = (HashMap<Material, V>) em.materialMap.clone();
+        } else {
+            if (m.isEmpty())
+                throw new IllegalArgumentException("Specified map is empty");
+
+            Class<K> keyType = (Class<K>) m.keySet().iterator().next().getClass();
+
+            if(m.keySet().iterator().next().getClass().isEnum()) {
+                realEnum = true;
+                realMap = new EnumMap(keyType);
+            } else {
+                materialMap = new HashMap<>(Material.values().length);
+            }
+
+            putAll(m);
+        }
+    }
+
+    public int size() {
+        return realEnum ? realMap.size() : materialMap.size();
+    }
+
+    public boolean containsValue(Object value) {
+        return realEnum ? realMap.containsValue(value) : materialMap.containsValue(value);
+    }
+
+    public boolean containsKey(Object key) {
+        return realEnum ? realMap.containsKey(key) : materialMap.containsKey(key);
+    }
+
+    public V get(Object key) {
+        return realEnum ? realMap.get(key) : materialMap.get(key);
+    }
+
+    public V put(K key, V value) {
+        return realEnum ? realMap.put(key, value) : materialMap.put((Material) key, value);
+    }
+
+    public V put(Material key, V value) {
+        return materialMap.put((Material) key, value);
+    }
+
+    public V remove(Object key) {
+        return realEnum ? realMap.remove(key) : materialMap.remove(key);
+    }
+
+    public void putAll(Map<? extends K, ? extends V> m) {
+        for(Entry<? extends K, ? extends V> entry : m.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void clear() {
+        if(realEnum)
+            realMap.clear();
+        else
+            materialMap.clear();
+    }
+
+    public Set<K> keySet() {
+        return realEnum ? (Set<K>) realMap.keySet() : (Set<K>) materialMap.keySet();
+    }
+
+    public Collection<V> values() {
+        return realEnum ? realMap.values() : materialMap.values();
+    }
+
+    public Set<Map.Entry<K,V>> entrySet() {
+        Set<Map.Entry<K, V>> set = new HashSet<>(realEnum ? realMap.size() : materialMap.size());
+
+        for(Map.Entry e : realEnum ? realMap.entrySet() : materialMap.entrySet()) {
+            set.add(e);
+        }
+
+        return set;
+    }
+
+    public boolean equals(Object o) {
+        return realEnum ? realMap.equals(o) : materialMap.equals(o);
+    }
+
+    public int hashCode() {
+        return realEnum ? realMap.hashCode() : materialMap.hashCode();
+    }
+
+    public CompatEnumMap<K, V> clone() {
+        return new CompatEnumMap<K, V>(this);
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumSet.java b/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumSet.java
new file mode 100644
index 000000000..48fe1cc69
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/compat/CompatEnumSet.java
@@ -0,0 +1,224 @@
+package org.bukkit.craftbukkit.compat;
+
+import org.bukkit.Material;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Objects;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumSet<E> extends AbstractSet<E> implements Cloneable, java.io.Serializable {
+
+    private boolean realEnum;
+    private EnumSet realSet;
+    private Enum[] realUniverse;
+
+    private HashSet<Material> materialSet;
+
+    private CompatEnumSet(Class elementType) {
+        if(elementType.isEnum()) {
+            realEnum = true;
+            realSet = EnumSet.noneOf(elementType);
+            try {
+                realUniverse = (Enum[]) elementType.getMethod("values").invoke(null);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            materialSet = new HashSet<>(Material.values().length);
+        }
+    }
+
+    public static <E> CompatEnumSet<E> noneOf(Class elementType) {
+        return new CompatEnumSet(elementType);
+    }
+
+    public static <E> CompatEnumSet<E> allOf(Class<E> elementType) {
+        CompatEnumSet<E> result = noneOf(elementType);
+        result.addAll();
+        return result;
+    }
+
+    void addAll() {
+        if(realEnum) {
+            realSet.addAll(Arrays.asList(realUniverse));
+        } else {
+            materialSet.addAll(Arrays.asList(Material.values()));
+        }
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(CompatEnumSet<E> s) {
+        return s.clone();
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(Collection<E> c) {
+        if (c instanceof CompatEnumSet) {
+            return ((CompatEnumSet<E>)c).clone();
+        } else {
+            if (c.isEmpty())
+                throw new IllegalArgumentException("Collection is empty");
+            Iterator<E> i = c.iterator();
+            E first = i.next();
+            CompatEnumSet<E> result = CompatEnumSet.of(first);
+            while (i.hasNext())
+                result.add(i.next());
+            return result;
+        }
+    }
+
+    public static <E> CompatEnumSet<E> complementOf(CompatEnumSet<E> s) {
+        CompatEnumSet<E> result = copyOf(s);
+        result.complement();
+        return result;
+    }
+
+    private static Class declaringClass(Class clazz) {
+        if(clazz.isEnum())
+            return clazz;
+
+        if(clazz.getSuperclass().isEnum())
+            return clazz.getSuperclass();
+
+        return clazz;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e.getClass()));
+        result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e1, Object e2) {
+        if(e2.getClass().isArray())
+            return of(e1, (Object[]) e2);
+
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add((E) e1);
+        result.add((E) e2);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4,
+                                                          E e5) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        result.add(e5);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object first, Object... rest) {
+        CompatEnumSet<E> result = noneOf(declaringClass(first.getClass()));
+        result.add((E) first);
+        for (Object e : rest)
+            result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> range(E _from, E to) {
+        Comparable<E> from = (Comparable) _from;
+
+        if (from.compareTo(to) > 0)
+            throw new IllegalArgumentException(from + " > " + to);
+
+        Class clazz = from.getClass().getDeclaringClass();
+        CompatEnumSet<E> result = noneOf(Objects.isNull(clazz) ? from.getClass() : clazz);
+        result.addRange((E) from, to);
+        return result;
+    }
+
+    void addRange(E from, E to) {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getMethod("addRange", Object.class, Object.class);
+                m.setAccessible(true);
+                m.invoke(realSet, from, to);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            int i1 = ((Material) from).ordinal();
+            int i2 = ((Material) to).ordinal();
+
+            for(int i = i1; i <= i2; ++i) {
+                materialSet.add(Material.values()[i]);
+            }
+        }
+    }
+
+    public boolean add(E o) {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getMethod("add", Object.class);
+                m.setAccessible(true);
+                return (boolean) m.invoke(realSet, o);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            return materialSet.add((Material) o);
+        }
+    }
+
+    public CompatEnumSet<E> clone() {
+        try {
+            return (CompatEnumSet<E>) super.clone();
+        } catch(CloneNotSupportedException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    void complement() {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getMethod("complement");
+                m.setAccessible(true);
+                m.invoke(realSet);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            for(Material material : Material.values()) {
+                if(materialSet.contains(material))
+                    materialSet.remove(material);
+                else
+                    materialSet.add(material);
+            }
+        }
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return realEnum ? (Iterator<E>) realSet.iterator() : (Iterator<E>) materialSet.iterator();
+    }
+
+    @Override
+    public int size() {
+        return realEnum ? realSet.size() : materialSet.size();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/compat/CompatJavaAgent.java b/src/main/java/org/bukkit/craftbukkit/compat/CompatJavaAgent.java
new file mode 100644
index 000000000..1f805328a
--- /dev/null
+++ b/src/main/java/org/bukkit/craftbukkit/compat/CompatJavaAgent.java
@@ -0,0 +1,98 @@
+package org.bukkit.craftbukkit.compat;
+
+import javassist.CannotCompileException;
+import javassist.ClassPool;
+import javassist.CtClass;
+import javassist.CtField;
+import javassist.bytecode.BadBytecode;
+import javassist.bytecode.ConstPool;
+import javassist.expr.ExprEditor;
+import javassist.expr.MethodCall;
+
+import java.io.ByteArrayInputStream;
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.lang.instrument.Instrumentation;
+import java.security.ProtectionDomain;
+import java.util.Arrays;
+
+public class CompatJavaAgent {
+
+    public static void agentmain(String args, Instrumentation instrumentation) {
+        instrumentation.addTransformer(new Transformer());
+    }
+
+    private static class Transformer implements ClassFileTransformer {
+
+        private CompatExprEditor editor;
+
+        Transformer() {
+            editor = new CompatExprEditor();
+        }
+
+        @Override
+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
+                                ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {
+            if(!loader.getClass().getName().equals("org.bukkit.plugin.java.PluginClassLoader"))
+                return classfileBuffer;
+
+            try {
+                ClassPool cp = ClassPool.getDefault();
+                CtClass cc = cp.makeClass(new ByteArrayInputStream(classfileBuffer));
+
+                ConstPool pool = cc.getClassFile().getConstPool();
+                pool.renameClass("java/util/EnumMap", "org/bukkit/craftbukkit/compat/CompatEnumMap");
+                pool.renameClass("java/util/EnumSet", "org/bukkit/craftbukkit/compat/CompatEnumSet");
+
+                for(CtField field : cc.getDeclaredFields()) {
+                    if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumMap;")) {
+                        field.setType(cp.get("org.bukkit.craftbukkit.compat.CompatEnumMap"));
+                    } else if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumSet;")) {
+                        field.setType(cp.get("org.bukkit.craftbukkit.compat.CompatEnumSet"));
+                    }
+                }
+
+                if(cc.getClassInitializer() != null)
+                    cc.getClassInitializer().instrument(editor);
+
+                Arrays.stream(cc.getDeclaredMethods()).forEach(method -> {
+                    String descriptor = method.getMethodInfo().getDescriptor();
+
+                    if(descriptor.contains("Ljava/util/EnumSet;") || descriptor.contains("Ljava/util/EnumMap;")) {
+                        method.getMethodInfo().setDescriptor(descriptor
+                            .replace("Ljava/util/EnumSet;", "Lorg/bukkit/craftbukkit/compat/CompatEnumSet;")
+                            .replace("Ljava/util/EnumMap;", "Lorg/bukkit/craftbukkit/compat/CompatEnumMap;"));
+
+                        try {
+                            method.getMethodInfo().rebuildStackMap(cp);
+                        } catch (BadBytecode badBytecode) {
+                            throw new RuntimeException(badBytecode);
+                        }
+                    }
+
+                    try {
+                        method.instrument(editor);
+                    } catch (CannotCompileException e) {
+                        throw new RuntimeException(e);
+                    }
+                });
+
+                return cc.toBytecode();
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        private static class CompatExprEditor extends ExprEditor {
+
+            @Override
+            public void edit(MethodCall m) throws CannotCompileException {
+                if(m.getClassName().equals("org.bukkit.craftbukkit.compat.CompatEnumSet") && (m.getMethodName().equals("of") || m.getMethodName().equals("noneOf"))) {
+                    m.replace("{ $_ = org.bukkit.craftbukkit.compat.CompatEnumSet." + m.getMethodName() + "($$); }");
+                } else if(m.getClassName().equals("org.bukkit.craftbukkit.compat.CompatEnumMap") && (m.getMethodName().equals("put"))) {
+                    m.replace("{ $_ = $0." + m.getMethodName() + "($$); }");
+                }
+            }
+        }
+    }
+}
-- 
2.23.0

