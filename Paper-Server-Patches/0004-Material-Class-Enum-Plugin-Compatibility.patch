From 647158ab8e979818a1c7c76bad772e7611c6f1e9 Mon Sep 17 00:00:00 2001
From: Indhi Rousseau <contact@thekinrar.fr>
Date: Wed, 9 Oct 2019 19:50:39 +0100
Subject: [PATCH] Material Class/Enum Plugin Compatibility


diff --git a/pom.xml b/pom.xml
index 54730360f..18af17e0b 100644
--- a/pom.xml
+++ b/pom.xml
@@ -119,6 +119,13 @@
             <version>1.3</version>
             <scope>test</scope>
         </dependency>
+        <!-- Papyrus - Compatibility -->
+        <dependency>
+            <groupId>org.javassist</groupId>
+            <artifactId>javassist</artifactId>
+            <version>3.25.0-GA</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <repositories>
@@ -254,6 +261,7 @@
                                     <shadedPattern>org.bukkit.craftbukkit.v${minecraft_version}</shadedPattern>
                                     <excludes>
                                         <exclude>org.bukkit.craftbukkit.Main*</exclude>
+                                        <exclude>fr.thekinrar.papyrus.compat.*</exclude>
                                     </excludes>
                                 </relocation>
                                 <relocation>
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java
new file mode 100644
index 000000000..9d46fe510
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java
@@ -0,0 +1,144 @@
+package fr.thekinrar.papyrus.compat;
+
+import org.bukkit.Material;
+
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumMap<K, V> extends AbstractMap<K, V> implements java.io.Serializable, Cloneable {
+
+    private boolean realEnum;
+    private AbstractMap<Object, V> realMap;
+
+    private HashMap<Material, V> materialMap;
+
+    public CompatEnumMap(Class keyType) {
+        if(keyType.isEnum()) {
+            realEnum = true;
+            realMap = new EnumMap(keyType);
+        } else {
+            materialMap = new HashMap<>(Material.values().length);
+        }
+    }
+
+    private AbstractMap<Object, V> cloneRealMap() {
+        try {
+            return (AbstractMap<Object, V>) realMap.getClass().getMethod("clone").invoke(realMap);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public CompatEnumMap(CompatEnumMap<K, ? extends V> m) {
+        realEnum = m.realEnum;
+
+        if(realEnum)
+            realMap = (AbstractMap<Object, V>) m.cloneRealMap();
+        else
+            materialMap = (HashMap<Material, V>) m.materialMap.clone();
+    }
+
+    public CompatEnumMap(Map<K, ? extends V> m) {
+        if (m instanceof CompatEnumMap) {
+            CompatEnumMap<K, ? extends V> em = (CompatEnumMap<K, ? extends V>) m;
+
+            realEnum = em.realEnum;
+
+            if(realEnum)
+                realMap = (AbstractMap<Object, V>) em.cloneRealMap();
+            else
+                materialMap = (HashMap<Material, V>) em.materialMap.clone();
+        } else {
+            if (m.isEmpty())
+                throw new IllegalArgumentException("Specified map is empty");
+
+            Class<K> keyType = (Class<K>) m.keySet().iterator().next().getClass();
+
+            if(m.keySet().iterator().next().getClass().isEnum()) {
+                realEnum = true;
+                realMap = new EnumMap(keyType);
+            } else {
+                materialMap = new HashMap<>(Material.values().length);
+            }
+
+            putAll(m);
+        }
+    }
+
+    public int size() {
+        return realEnum ? realMap.size() : materialMap.size();
+    }
+
+    public boolean containsValue(Object value) {
+        return realEnum ? realMap.containsValue(value) : materialMap.containsValue(value);
+    }
+
+    public boolean containsKey(Object key) {
+        return realEnum ? realMap.containsKey(key) : materialMap.containsKey(key);
+    }
+
+    public V get(Object key) {
+        return realEnum ? realMap.get(key) : materialMap.get(key);
+    }
+
+    public V put(K key, V value) {
+        return realEnum ? realMap.put(key, value) : materialMap.put((Material) key, value);
+    }
+
+    public V put(Material key, V value) {
+        return materialMap.put((Material) key, value);
+    }
+
+    public V remove(Object key) {
+        return realEnum ? realMap.remove(key) : materialMap.remove(key);
+    }
+
+    public void putAll(Map<? extends K, ? extends V> m) {
+        for(Entry<? extends K, ? extends V> entry : m.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void clear() {
+        if(realEnum)
+            realMap.clear();
+        else
+            materialMap.clear();
+    }
+
+    public Set<K> keySet() {
+        return realEnum ? (Set<K>) realMap.keySet() : (Set<K>) materialMap.keySet();
+    }
+
+    public Collection<V> values() {
+        return realEnum ? realMap.values() : materialMap.values();
+    }
+
+    public Set<Map.Entry<K,V>> entrySet() {
+        Set<Map.Entry<K, V>> set = new HashSet<>(realEnum ? realMap.size() : materialMap.size());
+
+        for(Map.Entry e : realEnum ? realMap.entrySet() : materialMap.entrySet()) {
+            set.add(e);
+        }
+
+        return set;
+    }
+
+    public boolean equals(Object o) {
+        return realEnum ? realMap.equals(o) : materialMap.equals(o);
+    }
+
+    public int hashCode() {
+        return realEnum ? realMap.hashCode() : materialMap.hashCode();
+    }
+
+    public CompatEnumMap<K, V> clone() {
+        return new CompatEnumMap<K, V>(this);
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java
new file mode 100644
index 000000000..5a4172fba
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java
@@ -0,0 +1,224 @@
+package fr.thekinrar.papyrus.compat;
+
+import org.bukkit.Material;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Objects;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumSet<E> extends AbstractSet<E> implements Cloneable, java.io.Serializable {
+
+    private boolean realEnum;
+    private EnumSet realSet;
+    private Enum[] realUniverse;
+
+    private HashSet<Material> materialSet;
+
+    private CompatEnumSet(Class elementType) {
+        if(elementType.isEnum()) {
+            realEnum = true;
+            realSet = EnumSet.noneOf(elementType);
+            try {
+                realUniverse = (Enum[]) elementType.getMethod("values").invoke(null);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            materialSet = new HashSet<>(Material.values().length);
+        }
+    }
+
+    public static <E> CompatEnumSet<E> noneOf(Class elementType) {
+        return new CompatEnumSet(elementType);
+    }
+
+    public static <E> CompatEnumSet<E> allOf(Class<E> elementType) {
+        CompatEnumSet<E> result = noneOf(elementType);
+        result.addAll();
+        return result;
+    }
+
+    void addAll() {
+        if(realEnum) {
+            realSet.addAll(Arrays.asList(realUniverse));
+        } else {
+            materialSet.addAll(Arrays.asList(Material.values()));
+        }
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(CompatEnumSet<E> s) {
+        return s.clone();
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(Collection<E> c) {
+        if (c instanceof CompatEnumSet) {
+            return ((CompatEnumSet<E>)c).clone();
+        } else {
+            if (c.isEmpty())
+                throw new IllegalArgumentException("Collection is empty");
+            Iterator<E> i = c.iterator();
+            E first = i.next();
+            CompatEnumSet<E> result = CompatEnumSet.of(first);
+            while (i.hasNext())
+                result.add(i.next());
+            return result;
+        }
+    }
+
+    public static <E> CompatEnumSet<E> complementOf(CompatEnumSet<E> s) {
+        CompatEnumSet<E> result = copyOf(s);
+        result.complement();
+        return result;
+    }
+
+    private static Class declaringClass(Class clazz) {
+        if(clazz.isEnum())
+            return clazz;
+
+        if(clazz.getSuperclass().isEnum())
+            return clazz.getSuperclass();
+
+        return clazz;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e.getClass()));
+        result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e1, Object e2) {
+        if(e2.getClass().isArray())
+            return of(e1, (Object[]) e2);
+
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add((E) e1);
+        result.add((E) e2);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4,
+                                                          E e5) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        result.add(e5);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object first, Object... rest) {
+        CompatEnumSet<E> result = noneOf(declaringClass(first.getClass()));
+        result.add((E) first);
+        for (Object e : rest)
+            result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> range(E _from, E to) {
+        Comparable<E> from = (Comparable) _from;
+
+        if (from.compareTo(to) > 0)
+            throw new IllegalArgumentException(from + " > " + to);
+
+        Class clazz = from.getClass().getDeclaringClass();
+        CompatEnumSet<E> result = noneOf(Objects.isNull(clazz) ? from.getClass() : clazz);
+        result.addRange((E) from, to);
+        return result;
+    }
+
+    void addRange(E from, E to) {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getDeclaredMethod("addRange", Object.class, Object.class);
+                m.setAccessible(true);
+                m.invoke(realSet, from, to);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            int i1 = ((Material) from).ordinal();
+            int i2 = ((Material) to).ordinal();
+
+            for(int i = i1; i <= i2; ++i) {
+                materialSet.add(Material.values()[i]);
+            }
+        }
+    }
+
+    public boolean add(E o) {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getMethod("add", Object.class);
+                m.setAccessible(true);
+                return (boolean) m.invoke(realSet, o);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            return materialSet.add((Material) o);
+        }
+    }
+
+    public CompatEnumSet<E> clone() {
+        try {
+            return (CompatEnumSet<E>) super.clone();
+        } catch(CloneNotSupportedException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    void complement() {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getDeclaredMethod("complement");
+                m.setAccessible(true);
+                m.invoke(realSet);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            for(Material material : Material.values()) {
+                if(materialSet.contains(material))
+                    materialSet.remove(material);
+                else
+                    materialSet.add(material);
+            }
+        }
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return realEnum ? (Iterator<E>) realSet.iterator() : (Iterator<E>) materialSet.iterator();
+    }
+
+    @Override
+    public int size() {
+        return realEnum ? realSet.size() : materialSet.size();
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java b/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java
new file mode 100644
index 000000000..8c847e32e
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java
@@ -0,0 +1,81 @@
+package fr.thekinrar.papyrus.compat;
+
+import javassist.CannotCompileException;
+import javassist.ClassPool;
+import javassist.CtClass;
+import javassist.CtField;
+import javassist.bytecode.BadBytecode;
+import javassist.bytecode.ConstPool;
+import javassist.expr.ExprEditor;
+import javassist.expr.MethodCall;
+
+import java.io.ByteArrayInputStream;
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.IllegalClassFormatException;
+import java.lang.instrument.Instrumentation;
+import java.security.ProtectionDomain;
+import java.util.Arrays;
+
+public class PapyrusCompat {
+
+    private static CompatExprEditor editor = new CompatExprEditor();
+
+    public static byte[] transform(byte[] classfileBuffer) {
+        try {
+            ClassPool cp = ClassPool.getDefault();
+            CtClass cc = cp.makeClass(new ByteArrayInputStream(classfileBuffer));
+
+            ConstPool pool = cc.getClassFile().getConstPool();
+            pool.renameClass("java/util/EnumMap", "fr/thekinrar/papyrus/compat/CompatEnumMap");
+            pool.renameClass("java/util/EnumSet", "fr/thekinrar/papyrus/compat/CompatEnumSet");
+
+            for(CtField field : cc.getDeclaredFields()) {
+                if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumMap;")) {
+                    field.setType(cp.get("fr.thekinrar.papyrus.compat.CompatEnumMap"));
+                } else if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumSet;")) {
+                    field.setType(cp.get("fr.thekinrar.papyrus.compat.CompatEnumSet"));
+                }
+            }
+
+            if(cc.getClassInitializer() != null)
+                cc.getClassInitializer().instrument(editor);
+
+            Arrays.stream(cc.getDeclaredMethods()).forEach(method -> {
+                String descriptor = method.getMethodInfo().getDescriptor();
+
+                if(descriptor.contains("Ljava/util/EnumSet;") || descriptor.contains("Ljava/util/EnumMap;")) {
+                    method.getMethodInfo().setDescriptor(descriptor
+                        .replace("Ljava/util/EnumSet;", "Lfr/thekinrar/papyrus/compat/CompatEnumSet;")
+                        .replace("Ljava/util/EnumMap;", "Lfr/thekinrar/papyrus/compat/CompatEnumMap;"));
+
+                    try {
+                        method.getMethodInfo().rebuildStackMap(cp);
+                    } catch (BadBytecode badBytecode) {
+                        throw new RuntimeException(badBytecode);
+                    }
+                }
+
+                try {
+                    method.instrument(editor);
+                } catch (CannotCompileException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+
+            return cc.toBytecode();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static class CompatExprEditor extends ExprEditor {
+        @Override
+        public void edit(MethodCall m) throws CannotCompileException {
+            if(m.getClassName().equals("fr.thekinrar.papyrus.compat.CompatEnumSet") && (m.getMethodName().equals("of") || m.getMethodName().equals("noneOf"))) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatEnumSet." + m.getMethodName() + "($$); }");
+            } else if(m.getClassName().equals("fr.thekinrar.papyrus.compat.CompatEnumMap") && (m.getMethodName().equals("put"))) {
+                m.replace("{ $_ = $0." + m.getMethodName() + "($$); }");
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
index 61f102355..b570b5804 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
@@ -14,6 +14,8 @@ import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
+
+import fr.thekinrar.papyrus.compat.PapyrusCompat;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import joptsimple.OptionSpec;
@@ -451,6 +453,6 @@ public class Commodore
             }
         }, 0 );
 
-        return cw.toByteArray();
+        return PapyrusCompat.transform(cw.toByteArray());
     }
 }
-- 
2.23.0

